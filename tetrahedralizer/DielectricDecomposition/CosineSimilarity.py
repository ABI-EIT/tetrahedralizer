"""
Tools for calculating and plotting the Cosine Similarity Matrix.
"""
import numpy as np
from LookupTables import *
import matplotlib
from matplotlib import cm
import matplotlib.pyplot as plt


def cosine_similarity(materials, frequencies):
    """
    Generates the cosine similarity matrix for the given list of materials and frequencies.
    :param materials: list of material names.
    :param frequencies: list of radiation frequencies (Hz)
    :return: np.array, np.array - cosine similarity matrices for permittivity and conductivity respectively.
    """

    # --------- #
    # Load Data #
    # --------- #

    er = []     # These will be lists of lists [mat, freq]
    cond = []

    for material in materials:
        a, b = permittivity_lookup(material, frequencies)
        # Normalise Spectra
        a, b = np.array(a), np.array(b)
        er.append(a / np.sqrt(np.dot(a, a)))
        cond.append(b / np.sqrt(np.dot(b, b)))

    # --------------------------------- #
    # Calculate matrix for Permittivity #
    # --------------------------------- #
    er_matrix = np.zeros(shape=(len(materials), len(materials)))
    for i in range(len(materials)):
        vec_i = er[i]
        for j in range(i + 1):
            vec_j = er[j]
            theta = np.arccos(np.dot(vec_i, vec_j)) * 180 / np.pi  # convert to deg for readability
            theta = 0.0 if np.isnan(theta) else theta  # i.e. numerical error
            er_matrix[i, j] = theta
            er_matrix[j, i] = theta  # matrix is symmetric

    # --------------------------------- #
    # Calculate matrix for Permittivity #
    # --------------------------------- #
    cond_matrix = np.zeros(shape=(len(materials), len(materials)))
    for i in range(len(materials)):
        vec_i = cond[i]
        for j in range(i + 1):
            vec_j = cond[j]
            theta = np.arccos(np.dot(vec_i, vec_j)) * 180 / np.pi  # convert to deg for readability
            theta = 0.0 if np.isnan(theta) else theta  # i.e. numerical error
            cond_matrix[i, j] = theta
            cond_matrix[j, i] = theta  # matrix is symmetric

    return er_matrix, cond_matrix



def cosine_similarity_plot(similarity_matrix, materials, title=''):
    """
    :param similarity_matrix: 2D np.array generated by the cosine_similarity method.
    :param materials: Respective list of material names.
    :param title: Title to be used on graph.
    :return:
    """
    fig, ax = plt.subplots(figsize=(8, 8))
    plt.imshow(similarity_matrix, cmap=cm.inferno)
    plt.xticks([_ for _ in range(len(materials))], materials, rotation='vertical')
    plt.yticks([_ for _ in range(len(materials))], materials, rotation='horizontal')
    plt.subplots_adjust(left=0.25, right=0.8, bottom=0.25, top=0.8)
    cbar = plt.colorbar()
    cbar.set_label('Cosine Angle (deg)', rotation=270, labelpad=20)
    plt.title(title)
    return fig, ax



# ------------- #
# USAGE EXAMPLE #
# ------------- #

if __name__ == '__main__':

    # Prepare Data Range
    _materials = VALID_MATERIALS
    _step_GHz = 0.1
    _frequencies = [f * 1e9 for f in np.arange(MIN_FREQUENCY / 1e9, MAX_FREQUENCY / 1e9, _step_GHz)]

    # Calculate Cosine Similarity Matrices
    _er_matrix, _cond_matrix = cosine_similarity(_materials, _frequencies)

    # Plot Results
    cosine_similarity_plot(_er_matrix, _materials, title='Permittivity')
    plt.show()
    input('Press Enter to Continue...')
    plt.close(plt.gcf())
    cosine_similarity_plot(_cond_matrix, _materials, title='Conductivity')
    plt.show()
    input('Press Enter to Continue...')
    plt.close(plt.gcf())




